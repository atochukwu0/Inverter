\chapter{Metodología}

En este capítulo se detalla la metodología seguida para el desarrollo del proyecto. Se incluye una explicación rápida de la filosofía KISS, las etapas del modelo en V y se describe el uso de un repositorio de GitHub para gestionar el proyecto.

\section{Filosofía}
En este proyecto, la filosofía KISS (\textit{Keep It Simple, Stupid}) ha sido un principio fundamental que ha guiado el diseño, la implementación y la validación del inversor. La simplicidad se ha considerado como una ventaja clave en todos los aspectos del proyecto, desde la elección de componentes hasta el desarrollo del \textit{firmware}.

Las razones por la que se cree que es necesario simplificar tanto como sea posible son las siguientes:
\begin{itemize}
	\item \textbf{Facilidad de comprensión:} Un diseño simple es más fácil de entender, lo que facilita la colaboración, el aprendizaje y el futuro desarrollo.
	\item \textbf{Mayor fiabilidad:} Los sistemas simples suelen ser más fiables que los complejos, ya que tienen menos puntos de fallo.
	\item \textbf{Facilidad de desarrollo:} Complicar un sistema que ya de por sí es complicado aumenta mucho el tiempo que se debe invertir para diseñarlo y hacerlo funcionar.
\end{itemize}

El trabajo consta de muchas partes relacionadas entre sí y se debe facilitar esta interacción entre las diferentes etapas del proyecto. Las decisiones que se han tomado para seguir esta filosofía son los siguientes:

\begin{itemize}
	\item \textbf{Minimizar la complejidad del diseño:} Se ha buscado simplificar el diseño del inversor evitando soluciones excesivamente complicadas. Se han priorizado diseños limpios y directos que cumplan con los requisitos del proyecto, mitigando posibles errores derivados de la complejidad.
	
	\item \textbf{Fomentar la modularidad:} Se ha promovido la modularidad en el diseño, dividiendo el sistema en componentes independientes y altamente cohesivos. En cuanto al \textit{hardware}, se separa el diseño en varias placas, permitiendo la evolución independiente de cada una. En cuanto al código, se separan las funcionalidades por archivos, conectándolos solamente si fuera necesario.
		
	\item \textbf{Priorizar la legibilidad:} En el desarrollo del \textit{firmware} se ha dado prioridad a la claridad y legibilidad del código sobre la eficiencia extrema o la optimización prematura. En cuanto al \textit{hardware}, se ha optado por crear esquemáticos detallados con notas explicativas en todos lados, y en el diseño de las placas se han añadido marcas y textos que ayudan a identificar rápidamente componentes y zonas durante el ensamblaje y desarrollo.
	
	\item \textbf{Simplificar los procesos de validación:} Se han diseñado procedimientos de prueba y validación simples, efectivos y reproducibles. Interesa que esta etapa sea ágil, y que durante las pruebas se pueda mantener el foco en los problemas relacionados estrictamente con lo que se está ensayando.	
	
\end{itemize}

\section{Modelo en V}
El modelo en V es un enfoque de desarrollo y validación que organiza las etapas del proyecto en forma de una 'V' invertida, donde cada etapa de desarrollo tiene una contraparte de validación. Esto asegura que la validación se considere desde el principio del proyecto y que cada fase de desarrollo tenga su correspondiente prueba o verificación asociada.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[node distance=2cm]
		
		% Nodes
		\node (requisitos) [block] {Requisitos del Sistema};
		\node (diseno_sistema) [block, below of=requisitos, xshift=0.7cm, yshift=-0.5cm] {Diseño del Sistema};
		\node (diseno_detallado) [block, below of=diseno_sistema, xshift=0.7cm, yshift=-0.5cm] {Diseño Detallado};
		\node (implementacion) [block, below of=diseno_detallado, xshift=0.7cm, yshift=-0.5cm] {Implementación};
		\node (pruebas_unitarias) [block, right of=implementacion, xshift=5cm, yshift=0cm] {Pruebas Unitarias};
		\node (pruebas_integracion) [block, above of=pruebas_unitarias, xshift=0.7cm, yshift=0.5cm] {Pruebas de Integración};
		\node (pruebas_sistema) [block, above of=pruebas_integracion, xshift=0.7cm, yshift=0.5cm] {Pruebas de Sistema};
		\node (pruebas_aceptacion) [block, above of=pruebas_sistema, xshift=0.7cm, yshift=0.5cm] {Pruebas de Aceptación};
		
		% Arrows
		\draw [arrow] (requisitos) -- (diseno_sistema);
		\draw [arrow] (diseno_sistema) -- (diseno_detallado);
		\draw [arrow] (diseno_detallado) -- (implementacion);
		\draw [arrow] (implementacion) -- (pruebas_unitarias);
		\draw [arrow] (pruebas_unitarias) -- (pruebas_integracion);
		\draw [arrow] (pruebas_integracion) -- (pruebas_sistema);
		\draw [arrow] (pruebas_sistema) -- (pruebas_aceptacion);
		
		% Additional arrows for test design
		\draw [arrow] (requisitos.east) -- ++(3.5cm,0) |- node[anchor=south]{Plan de Pruebas} (pruebas_aceptacion.west);
		\draw [arrow] (diseno_sistema.east) -- ++(3cm,0) |- node[anchor=south]{Plan de Pruebas} (pruebas_sistema.west);
		\draw [arrow] (diseno_detallado.east) -- ++(2.5cm,0) |- node[anchor=south]{Plan de Pruebas} (pruebas_integracion.west);
		\draw [arrow] (implementacion.east) -- ++(1.75cm,0) |- node[anchor=south]{Plan de Pruebas} (pruebas_unitarias.west);
	\end{tikzpicture}
	\caption{Modelo en V para el desarrollo y validación de sistemas.}
\end{figure}

En el modelo en V, las etapas de desarrollo se encuentran en el lado izquierdo de la 'V', comenzando desde los requisitos del sistema hasta la implementación y codificación. Por otro lado, las etapas de validación se encuentran en el lado derecho de la 'V', comenzando desde las pruebas unitarias y de integración hasta las pruebas de sistema y aceptación.

El modelo en V proporciona una estructura clara y sistemática para el desarrollo y validación del convertidor, asegurando que cada etapa tenga su correspondiente prueba de validación y que los resultados sean coherentes con los objetivos del proyecto. Sin embargo, es necesario ser pragmático y eficaz con la validación, puesto que tiende a llevar más tiempo del necesario si se sigue una metodología de forma estricta. Por ello, a lo largo de todo el proceso de diseño y de verificación se ha tomado la libertad de usar el modelo en V para aquello para lo que es útil, y ser más ágil con aquellas partes que lo requieran.

A continuación se enumeran las etapas del proyecto, aplicando pragmáticamente el modelo en V a este trabajo en específico.
\begin{enumerate}
\item \textbf{Definición de requisitos}

La primera etapa del proyecto se centra en la definición de los requisitos del inversor trifásico y su control. Aquí se establecen los objetivos, las especificaciones técnicas y los criterios que guiarán todo el desarrollo. Además, se identifican las necesidades y expectativas del equipo de Formula Student, asegurando que el proyecto cumpla con sus requerimientos específicos. La duración de esta etapa es excepcionalmente larga, pues requiere de mucha familiaridad con el entorno de la Formula Student y conocimiento sobre las necesidades reales del equipo.

\item \textbf{Modelo continuo y simulación del control}

La siguiente etapa es el diseño del modelo en continuo y el desarrollo del control en Simulink. Aquí, se crea un modelo matemático del inversor y del motor PMSM y se implementa el control vectorial (FOC). Este proceso implica una comprensión profunda de la teoría detrás de los motores eléctricos y el diseño del control. Se basará en la representación de la energía macroscópica (EMR) con el fin de ilustrar la aplicación final del motor. La duración estimada para esta fase es de aproximadamente 2 meses.

\item \textbf{Discretización del modelo y simulación de la conmutación}

Al acabar la etapa anterior, se trabaja en la discretización del modelo y la simulación de la conmutación de los interruptores de potencia en PLECS. Aquí se tiene en cuenta la naturaleza discreta de la electrónica de potencia y se simula el comportamiento del inversor en el dominio del tiempo discreto. Además, esta simulación incorpora también el modelo térmico, con lo que se pueden extraer las pérdidas del inversor. Esta fase dura alrededor de 2 semanas, pues gran parte de lo ya modelado se puede reutilizar para el nuevo modelo discreto.

\item \textbf{Desarrollo del \textit{hardware}}

Con el diseño del control y la simulación de la conmutación como base, se procede al diseño del \textit{hardware}. Esto implica seleccionar componentes, diseñar esquemáticos y PCBs y planificar su validación. La duración estimada para esta etapa es de 3 a 4 meses, y se solapa parcialmente con el diseño del \textit{firmware}.

\item \textbf{Desarrollo del \textit{firmware}}

Simultáneamente con el diseño del \textit{hardware}, se trabaja en el desarrollo del \textit{firmware}. Esto incluye programar el microcontrolador que controlará el inversor y la implementación del algoritmo de control. Se utilizará una placa de evaluación antes de tener la placa de control propia con tal de acelerar el desarrollo. La duración estimada para esta fase es de aproximadamente 4 meses.

\item \textbf{Validación del \textit{hardware}}

Una vez que el \textit{hardware} se está construyendo, se procede a la validación con las pruebas planeadas anteriormente. La duración estimada para esta etapa es de aproximadamente 3 a 4 meses y se superpone con el desarrollo del \textit{firmware}.

\item \textbf{Validación del \textit{firmware}}

La validación del \textit{firmware} se realiza una vez que el \textit{hardware} está validado, y mayoritariamente, se puede realizar durante el mismo desarrollo del código. Aquí, se llevan a cabo pruebas unitarias para garantizar que cada módulo funcione según lo previsto y ver que las simulaciones y cálculos previos se ajusten a la realidad. La duración estimada para esta etapa es de 2 meses.

\item \textbf{Documentación y preparación para la implementación}

La fase final del proyecto se enfoca en la documentación y la preparación para su implementación en los monoplazas de e-Tech Racing. La duración estimada para esta etapa es de aproximadamente un par de semanas. 

\end{enumerate}

\newpage

\begin{landscape}
	\begin{figure}[H]
		\centering
		\begin{ganttchart}[
			hgrid,
			vgrid,
			y unit chart=0.7cm,
			x unit=1.5cm,
			time slot format=isodate-yearmonth,
			time slot unit=month,
			today=2024-06,
			today rule/.style={
				draw=blue,
				dash pattern=on 3.5pt off 4.5pt,
				line width=1.5pt
			},
			bar/.append style={fill=blue!30},
			bar label font=\footnotesize,
			group label font=\footnotesize,
			milestone label font=\footnotesize,
			milestone/.append style={fill=red, rounded corners=2pt},
    		newline shortcut=true,
			]{2023-09}{2024-06}
			\gantttitlecalendar{year, month=shortname} \\ % abreviar nombres de meses
			\ganttbar{Modelo continuo y simulación del control}{2023-09}{2023-10} \\
			\ganttbar{Discretización del modelo y simulación de la conmutación}{2023-10}{2023-11} \\
			\ganttbar{Desarrollo del \textit{hardware}}{2023-10}{2024-01} \\
			\ganttbar{Desarrollo del \textit{firmware}}{2024-01}{2024-06} \\
			\ganttbar{Validación del \textit{hardware}}{2024-02}{2024-05} \\
			\ganttbar{Validación del \textit{firmware}}{2024-05}{2024-06} \\
			\ganttbar{Documentación y preparación para la implementación}{2024-06}{2024-06} \\
			
			\ganttmilestone{Trabajo finalizado}{2024-06}
			\end{ganttchart}
			\caption{Diagrama de Gantt para el proyecto}	
	\end{figure}
\end{landscape}
	
\newpage

Es importante destacar que las etapas de diseño del \textit{hardware} y del \textit{firmware} pueden superponerse y solaparse con otras etapas, lo que permite un desarrollo más ágil y eficiente del proyecto. La superposición de estas etapas es esencial para cumplir con los plazos y garantizar que el proyecto avance de manera constante. El trabajo se ha realizado en el marco de un año académico, de septiembre a junio, aunque la definición de requisitos y los primeros pasos del modelo continuo se realizaron antes del comienzo del trabajo.

\section{Gestión del proyecto con Git}
\subsection{Introducción a Git}
Git es un sistema de control de versiones distribuido, diseñado para rastrear cambios en archivos y coordinar el trabajo entre múltiples personas en proyectos de desarrollo de \textit{software}. Utiliza un enfoque descentralizado, lo que significa que cada desarrollador tiene una copia completa del historial de cambios del proyecto. Git facilita el trabajo colaborativo, la gestión de cambios y la integración continua en proyectos de cualquier tamaño.

\subsection{Funcionamiento de Git}
Git trabaja mediante la creación de instantáneas (\textit{commits}) de los archivos en un repositorio. Cada vez que se realiza un cambio significativo en los archivos del proyecto, se crea un nuevo \textit{commit} que contiene una instantánea del estado de esos archivos en ese momento. Estos \textit{commits} se organizan en ramas (\textit{branches}), que permiten trabajar en paralelo en diferentes características o correcciones de errores sin afectar al código principal. Las ramas se fusionan (\textit{merge}) cuando el trabajo está completo y se quiere incorporar al código principal. En este proyecto solo se ha usado una rama puesto que solo hay un desarrollador.

\subsection{Por qué utilizar un sistema de control de versiones}
El uso de un sistema de control de versiones como Git proporciona numerosos beneficios para el desarrollo de proyectos de ingeniería, incluyendo:

\begin{itemize}
	\item \textbf{Historial de cambios:} Permite mantener un registro detallado de todas las modificaciones realizadas en el código y otros archivos del proyecto, lo que facilita la identificación de errores y el seguimiento del progreso del desarrollo.
	\item \textbf{Colaboración:} Facilita el trabajo en equipo al permitir que múltiples desarrolladores trabajen simultáneamente en diferentes aspectos del proyecto, sin temor a sobrescribir los cambios de los demás.
	\item \textbf{Seguridad:} Proporciona una copia de seguridad del código en caso de pérdida o corrupción de los archivos locales.
	\item \textbf{Experimentación:} Permite probar nuevas ideas y características en ramas separadas sin afectar al código principal.
\end{itemize}

\subsection{Uso de Git en el proyecto}
En el desarrollo de este proyecto, Git se utilizó para gestionar no solo el \textit{firmware}, sino también las simulaciones, la documentación y el diseño del \textit{hardware}. Cada aspecto del proyecto se organizó en una carpeta del mismo repositorio de Git, lo que permitió un seguimiento preciso de los cambios.

\subsection{GitHub}
GitHub es una plataforma de alojamiento de código que utiliza Git como sistema de control de versiones. Ofrece funciones adicionales como seguimiento de problemas, gestión de proyectos y revisión de código. En este proyecto, se utilizó GitHub para alojar el repositorio de Git.

\subsection{Automatización de la documentación y \textit{releases}}
Una de las ventajas de utilizar Git y GitHub es la capacidad de automatizar tareas como la generación de documentación y la creación de \textit{releases}. En este proyecto, se generó automáticamente una \textit{wiki} utilizando los contenidos de esta memoria, lo cual facilitó la creación y el mantenimiento de documentación actualizada.

Además, se realizaron \textit{releases} de \textit{hardware} mediante el etiquetado de versiones en Git. Cada vez que se solicitaban PCBs, se creaba una nueva \textit{release} que incluía los archivos de fabricación de las PCBs, una lista detallada de los cambios realizados desde la última versión, y se iban actualizando las \textit{release notes} con los errores que se iban encontrando.


